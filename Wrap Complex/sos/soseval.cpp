/*
 * soseval.C -- Method definitions for SOS Evaluators
 *
 * author -- Mike Facello
 *
 * date -- 12/4/96
 */

#include "soseval.h"
#include "li/liminor.h"

/*-----------------------------------------------------------------------*/
/*--------------------------- CLASS SOS_RESULT --------------------------*/
/*-----------------------------------------------------------------------*/


SOS_Result::
SOS_Result (void)
  : value_ (0),
    epsilon_ (1)
{
  // Do nothing...  
}

/*-----------------------------------------------------------------------*/


SOS_Result::
~SOS_Result (void)
{
  // Do nothing...
}

/*-----------------------------------------------------------------------*/

int SOS_Result::
sign (void) const
{
  return signum_;
}

/*-----------------------------------------------------------------------*/

ostream&
operator<< (ostream& s, SOS_Result& result)
{
 // s << result.value_;
  return s;
}


/*-----------------------------------------------------------------------*/
/*-------------------------- CLASS SOS_EVALUATOR ------------------------*/
/*-----------------------------------------------------------------------*/

SOS_Evaluator::
SOS_Evaluator (char *name)
  : counter_ (1)
{
  name_ = name;
  num_calls_ = 0;
  minorEval_ = new LI_VertMinorEvaluator;

  //  max_  = MAX_t + 1;      // These next two are really constants...
  //  dimension_ = DIM;
}

/*-----------------------------------------------------------------------*/

SOS_Evaluator::
~SOS_Evaluator (void)
{
  delete minorEval_;
}

/*-----------------------------------------------------------------------*/

ostream&
operator<< (ostream& s, SOS_Evaluator &evaluator)
{
  s.width(12);
  s << evaluator.num_calls_ << " . SoS " << evaluator.name_ 
    << " evaluations\n";

  return s;
}


/*-----------------------------------------------------------------------*/

void  SOS_Evaluator::
outputDepths (ostream& s)
{
  register int i = 0;

  s << "\nSoS " << name_ << ", non-zero depth counters\n" << minorEval_;
  while ((i < getMax()) and (counter_[i] > 0))
    {
      s.width(12);
      s << counter_[i++] << endl;
    }
}


/*-----------------------------------------------------------------------*/

int SOS_Evaluator::
getMax (void)
{
  return (MAX_T);
}


/*-----------------------------------------------------------------------*/
/*-------------------------- CLASS Lambda3_Eval -------------------------*/
/*-----------------------------------------------------------------------*/

Lambda3_Eval::
Lambda3_Eval (char *name) 
  : SOS_Evaluator (name)
    //    max_ (MAX_t + 1),
    //    dimension_ (DIM)
{
  // Do nothing...
}

/*-----------------------------------------------------------------------*/

void Lambda3_Eval::
eval (const LI_Point &p1, const LI_Point &p2, const LI_Point &p3, 
      VIndex i, VIndex j, VIndex k,
      SOS_Result & result)
{
  num_calls_ ++;
  Touch_args (k);
  
  /* C code generated by 'ccode' from 'gee' file "Lambda3.out" */
  Initialize ();
  Epsilon_Term (0);
  minorEval_->minor3 (p1, p2, p3, 1, 2, 0, result.value_);
  Positive_Coefficient ();
  Epsilon_Term (1);
  Epsilon (i,2);
  minorEval_->minor2 (p2, p3, 1, 0, result.value_);
  Negative_Coefficient ();
  Epsilon_Term (2);
  Epsilon (i,1);
  minorEval_->minor2 (p2, p3, 2, 0, result.value_);
  Positive_Coefficient ();
  Epsilon_Term (3);
  Epsilon (j,2);
  minorEval_->minor2 (p1, p3, 1, 0, result.value_);
  Positive_Coefficient ();
  Epsilon_Term (4);
  Epsilon (j,2);
  Epsilon (i,1);
  result.value_ = LI (1);
  Coefficient ();
  Finish ();
}


/*-----------------------------------------------------------------------*/

int Lambda3_Eval::
getMax (void)
{
  return (MAX_T);
}




/*-----------------------------------------------------------------------*/
/*-------------------------- CLASS Lambda4_Eval -------------------------*/
/*-----------------------------------------------------------------------*/

Lambda4_Eval::
Lambda4_Eval (char *name) 
  : SOS_Evaluator (name)
    //    max_ (MAX_t + 1),
    //    dimension_ (DIM)
{
  // Do nothing...
}

/*-----------------------------------------------------------------------*/

void Lambda4_Eval::
eval (const LI_Point &p1, const LI_Point & p2, const LI_Point & p3,
      const LI_Point & p4, VIndex i, VIndex j, VIndex k, VIndex l,
      SOS_Result & result)
{
  num_calls_ ++;
  Touch_args (l);
  
  /* C code generated by 'ccode' from 'gee' file "Lambda4.out" */
  Initialize ();
  Epsilon_Term (0);
  minorEval_->minor4 (p1, p2, p3, p4, 1, 2, 3, 0, result.value_);
  Positive_Coefficient ();
  Epsilon_Term (1);
  Epsilon (i,3);
  minorEval_->minor3 (p2, p3, p4, 1, 2, 0, result.value_);
  Positive_Coefficient ();
  Epsilon_Term (2);
  Epsilon (i,2);
  minorEval_->minor3 (p2, p3, p4, 1, 3, 0, result.value_);
  Negative_Coefficient ();
  Epsilon_Term (3);
  Epsilon (i,1);
  minorEval_->minor3 (p2, p3, p4, 2, 3, 0, result.value_);
  Positive_Coefficient ();
  Epsilon_Term (4);
  Epsilon (j,3);
  minorEval_->minor3 (p1, p3, p4, 1, 2, 0, result.value_);
  Negative_Coefficient ();
  Epsilon_Term (5);
  Epsilon (j,3);
  Epsilon (i,2);
  minorEval_->minor2 (p3, p4, 1, 0, result.value_);
  Positive_Coefficient ();
  Epsilon_Term (6);
  Epsilon (j,3);
  Epsilon (i,1);
  minorEval_->minor2 (p3, p4, 2, 0, result.value_);
  Negative_Coefficient ();
  Epsilon_Term (7);
  Epsilon (j,2);
  minorEval_->minor3 (p1, p3, p4, 1, 3, 0, result.value_);
  Positive_Coefficient ();
  Epsilon_Term (8);
  Epsilon (j,2);
  Epsilon (i,1);
  minorEval_->minor2 (p3, p4, 3, 0, result.value_);
  Positive_Coefficient ();
  Epsilon_Term (9);
  Epsilon (j,1);
  minorEval_->minor3 (p1, p3, p4, 2, 3, 0, result.value_);
  Negative_Coefficient ();
  Epsilon_Term (10);
  Epsilon (k,3);
  minorEval_->minor3 (p1, p2, p4, 1, 2, 0, result.value_);
  Positive_Coefficient ();
  Epsilon_Term (11);
  Epsilon (k,3);
  Epsilon (i,2);
  minorEval_->minor2 (p2, p4, 1, 0, result.value_);
  Negative_Coefficient ();
  Epsilon_Term (12);
  Epsilon (k,3);
  Epsilon (i,1);
  minorEval_->minor2 (p2, p4, 2, 0, result.value_);
  Positive_Coefficient ();
  Epsilon_Term (13);
  Epsilon (k,3);
  Epsilon (j,2);
  minorEval_->minor2 (p1, p4, 1, 0, result.value_);
  Positive_Coefficient ();
  Epsilon_Term (14);
  Epsilon (k,3);
  Epsilon (j,2);
  Epsilon (i,1);
  result.value_ = LI (1);
  Coefficient ();
  Finish ();
}


/*-----------------------------------------------------------------------*/

int Lambda4_Eval::
getMax (void)
{
  return (MAX_T);
}


/*-----------------------------------------------------------------------*/
/*-------------------------- CLASS Lambda5_Eval -------------------------*/
/*-----------------------------------------------------------------------*/

Lambda5_Eval::
Lambda5_Eval (char *name) 
  : SOS_Evaluator (name)
    //    max_ (MAX_t + 1),
    //    dimension_ (DIM)
{
  // Do nothing...
}

/*-----------------------------------------------------------------------*/

void Lambda5_Eval::
eval (const LI_Point & p1, const LI_Point & p2, const LI_Point & p3,
      const LI_Point & p4, const LI_Point & p5,
      VIndex i, VIndex j, VIndex k, VIndex l, VIndex m,
      SOS_Result & result)
{
  num_calls_ ++;
  Touch_args (m);

  /* C code generated by 'ccode' from 'gee' file "Lambda5.out" */
  Initialize ();
  Epsilon_Term (0);
  minorEval_->minor5 (p1, p2, p3, p4, p5, 1, 2, 3, 4, 0, result.value_);
  Positive_Coefficient ();
  Epsilon_Term (1);
  Epsilon (i,4);
  minorEval_->minor4 (p2, p3, p4, p5, 1, 2, 3, 0, result.value_);
  Negative_Coefficient ();
  Epsilon_Term (2);
  Epsilon (i,3);
  minorEval_->minor4 (p2, p3, p4, p5, 1, 2, 4, 0, result.value_);
  Positive_Coefficient ();
  Epsilon_Term (3);
  Epsilon (i,2);
  minorEval_->minor4 (p2, p3, p4, p5, 1, 3, 4, 0, result.value_);
  Negative_Coefficient ();
  Epsilon_Term (4);
  Epsilon (i,1);
  minorEval_->minor4 (p2, p3, p4, p5, 2, 3, 4, 0, result.value_);
  Positive_Coefficient ();
  Epsilon_Term (5);
  Epsilon (j,4);
  minorEval_->minor4 (p1, p3, p4, p5, 1, 2, 3, 0, result.value_);
  Positive_Coefficient ();
  Epsilon_Term (6);
  Epsilon (j,4);
  Epsilon (i,3);
  minorEval_->minor3 (p3, p4, p5, 1, 2, 0, result.value_);
  Positive_Coefficient ();
  Epsilon_Term (7);
  Epsilon (j,4);
  Epsilon (i,2);
  minorEval_->minor3 (p3, p4, p5, 1, 3, 0, result.value_);
  Negative_Coefficient ();
  Epsilon_Term (8);
  Epsilon (j,4);
  Epsilon (i,1);
  minorEval_->minor3 (p3, p4, p5, 2, 3, 0, result.value_);
  Positive_Coefficient ();
  Epsilon_Term (9);
  Epsilon (j,3);
  minorEval_->minor4 (p1, p3, p4, p5, 1, 2, 4, 0, result.value_);
  Negative_Coefficient ();
  Epsilon_Term (10);
  Epsilon (j,3);
  Epsilon (i,2);
  minorEval_->minor3 (p3, p4, p5, 1, 4, 0, result.value_);
  Positive_Coefficient ();
  Epsilon_Term (11);
  Epsilon (j,3);
  Epsilon (i,1);
  minorEval_->minor3 (p3, p4, p5, 2, 4, 0, result.value_);
  Negative_Coefficient ();
  Epsilon_Term (12);
  Epsilon (j,2);
  minorEval_->minor4 (p1, p3, p4, p5, 1, 3, 4, 0, result.value_);
  Positive_Coefficient ();
  Epsilon_Term (13);
  Epsilon (j,2);
  Epsilon (i,1);
  minorEval_->minor3 (p3, p4, p5, 3, 4, 0, result.value_);
  Positive_Coefficient ();
  Epsilon_Term (14);
  Epsilon (j,1);
  minorEval_->minor4 (p1, p3, p4, p5, 2, 3, 4, 0, result.value_);
  Negative_Coefficient ();
  Epsilon_Term (15);
  Epsilon (k,4);
  minorEval_->minor4 (p1, p2, p4, p5, 1, 2, 3, 0, result.value_);
  Negative_Coefficient ();
  Epsilon_Term (16);
  Epsilon (k,4);
  Epsilon (i,3);
  minorEval_->minor3 (p2, p4, p5, 1, 2, 0, result.value_);
  Negative_Coefficient ();
  Epsilon_Term (17);
  Epsilon (k,4);
  Epsilon (i,2);
  minorEval_->minor3 (p2, p4, p5, 1, 3, 0, result.value_);
  Positive_Coefficient ();
  Epsilon_Term (18);
  Epsilon (k,4);
  Epsilon (i,1);
  minorEval_->minor3 (p2, p4, p5, 2, 3, 0, result.value_);
  Negative_Coefficient ();
  Epsilon_Term (19);
  Epsilon (k,4);
  Epsilon (j,3);
  minorEval_->minor3 (p1, p4, p5, 1, 2, 0, result.value_);
  Positive_Coefficient ();
  Epsilon_Term (20);
  Epsilon (k,4);
  Epsilon (j,3);
  Epsilon (i,2);
  minorEval_->minor2 (p4, p5, 1, 0, result.value_);
  Negative_Coefficient ();
  Epsilon_Term (21);
  Epsilon (k,4);
  Epsilon (j,3);
  Epsilon (i,1);
  minorEval_->minor2 (p4, p5, 2, 0, result.value_);
  Positive_Coefficient ();
  Epsilon_Term (22);
  Epsilon (k,4);
  Epsilon (j,2);
  minorEval_->minor3 (p1, p4, p5, 1, 3, 0, result.value_);
  Negative_Coefficient ();
  Epsilon_Term (23);
  Epsilon (k,4);
  Epsilon (j,2);
  Epsilon (i,1);
  minorEval_->minor2 (p4, p5, 3, 0, result.value_);
  Negative_Coefficient ();
  Epsilon_Term (24);
  Epsilon (k,4);
  Epsilon (j,1);
  minorEval_->minor3 (p1, p4, p5, 2, 3, 0, result.value_);
  Positive_Coefficient ();
  Epsilon_Term (25);
  Epsilon (k,3);
  minorEval_->minor4 (p1, p2, p4, p5, 1, 2, 4, 0, result.value_);
  Positive_Coefficient ();
  Epsilon_Term (26);
  Epsilon (k,3);
  Epsilon (i,2);
  minorEval_->minor3 (p2, p4, p5, 1, 4, 0, result.value_);
  Negative_Coefficient ();
  Epsilon_Term (27);
  Epsilon (k,3);
  Epsilon (i,1);
  minorEval_->minor3 (p2, p4, p5, 2, 4, 0, result.value_);
  Positive_Coefficient ();
  Epsilon_Term (28);
  Epsilon (k,3);
  Epsilon (j,2);
  minorEval_->minor3 (p1, p4, p5, 1, 4, 0, result.value_);
  Positive_Coefficient ();
  Epsilon_Term (29);
  Epsilon (k,3);
  Epsilon (j,2);
  Epsilon (i,1);
  minorEval_->minor2 (p4, p5, 4, 0, result.value_);
  Positive_Coefficient ();
  Epsilon_Term (30);
  Epsilon (k,3);
  Epsilon (j,1);
  minorEval_->minor3 (p1, p4, p5, 2, 4, 0, result.value_);
  Negative_Coefficient ();
  Epsilon_Term (31);
  Epsilon (k,2);
  minorEval_->minor4 (p1, p2, p4, p5, 1, 3, 4, 0, result.value_);
  Negative_Coefficient ();
  Epsilon_Term (32);
  Epsilon (k,2);
  Epsilon (i,1);
  minorEval_->minor3 (p2, p4, p5, 3, 4, 0, result.value_);
  Negative_Coefficient ();
  Epsilon_Term (33);
  Epsilon (k,2);
  Epsilon (j,1);
  minorEval_->minor3 (p1, p4, p5, 3, 4, 0, result.value_);
  Positive_Coefficient ();
  Epsilon_Term (34);
  Epsilon (k,1);
  minorEval_->minor4 (p1, p2, p4, p5, 2, 3, 4, 0, result.value_);
  Positive_Coefficient ();
  Epsilon_Term (35);
  Epsilon (l,4);
  minorEval_->minor4 (p1, p2, p3, p5, 1, 2, 3, 0, result.value_);
  Positive_Coefficient ();
  Epsilon_Term (36);
  Epsilon (l,4);
  Epsilon (i,3);
  minorEval_->minor3 (p2, p3, p5, 1, 2, 0, result.value_);
  Positive_Coefficient ();			
  Epsilon_Term (37);
  Epsilon (l,4);
  Epsilon (i,2);
  minorEval_->minor3 (p2, p3, p5, 1, 3, 0, result.value_);
  Negative_Coefficient ();
  Epsilon_Term (38);
  Epsilon (l,4);
  Epsilon (i,1);
  minorEval_->minor3 (p2, p3, p5, 2, 3, 0, result.value_);
  Positive_Coefficient ();
  Epsilon_Term (39);
  Epsilon (l,4);
  Epsilon (j,3);
  minorEval_->minor3 (p1, p3, p5, 1, 2, 0, result.value_);
  Negative_Coefficient ();
  Epsilon_Term (40);
  Epsilon (l,4);
  Epsilon (j,3);
  Epsilon (i,2);
  minorEval_->minor2 (p3, p5, 1, 0, result.value_);
  Positive_Coefficient ();
  Epsilon_Term (41);
  Epsilon (l,4);
  Epsilon (j,3);
  Epsilon (i,1);
  minorEval_->minor2 (p3, p5, 2, 0, result.value_);
  Negative_Coefficient ();
  Epsilon_Term (42);
  Epsilon (l,4);
  Epsilon (j,2);
  minorEval_->minor3 (p1, p3, p5, 1, 3, 0, result.value_);
  Positive_Coefficient ();
  Epsilon_Term (43);
  Epsilon (l,4);
  Epsilon (j,2);
  Epsilon (i,1);
  minorEval_->minor2 (p3, p5, 3, 0, result.value_);
  Positive_Coefficient ();
  Epsilon_Term (44);
  Epsilon (l,4);
  Epsilon (j,1);
  minorEval_->minor3 (p1, p3, p5, 2, 3, 0, result.value_);
  Negative_Coefficient ();
  Epsilon_Term (45);
  Epsilon (l,4);
  Epsilon (k,3);
  minorEval_->minor3 (p1, p2, p5, 1, 2, 0, result.value_);
  Positive_Coefficient ();
  Epsilon_Term (46);
  Epsilon (l,4);
  Epsilon (k,3);
  Epsilon (i,2);
  minorEval_->minor2 (p2, p5, 1, 0, result.value_);
  Negative_Coefficient ();
  Epsilon_Term (47);
  Epsilon (l,4);
  Epsilon (k,3);
  Epsilon (i,1);
  minorEval_->minor2 (p2, p5, 2, 0, result.value_);
  Positive_Coefficient ();
  Epsilon_Term (48);
  Epsilon (l,4);
  Epsilon (k,3);
  Epsilon (j,2);
  minorEval_->minor2 (p1, p5, 1, 0, result.value_);
  Positive_Coefficient ();
  Epsilon_Term (49);
  Epsilon (l,4);
  Epsilon (k,3);
  Epsilon (j,2);
  Epsilon (i,1);
  result.value_ = LI (1);
  Coefficient ();
  Finish ();
}

/*-----------------------------------------------------------------------*/

int Lambda5_Eval::
getMax (void)
{
  return (MAX_T);
}


/*-----------------------------------------------------------------------*/
/*-----------------------------------------------------------------------*/
/*-----------------------------------------------------------------------*/
/*-----------------------------------------------------------------------*/
/*-----------------------------------------------------------------------*/
